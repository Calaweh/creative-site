import './style.css';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass }     from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass }from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

// ─── UTILS: IMPROVED NOISE ───────────────────────────────────
class SimpleNoise {
  constructor() {
    this.perm = new Uint8Array(512);
    const p = new Uint8Array(256);
    for(let i=0; i<256; i++) p[i] = i;
    for(let i=0; i<256; i++) {
      let r = Math.floor(Math.random() * 256), t = p[i];
      p[i] = p[r]; p[r] = t;
    }
    for(let i=0; i<512; i++) this.perm[i] = p[i & 255];
    this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
  }
  dot(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }
  noise(xin, yin, zin) {
    const F3 = 1.0/3.0, S3 = 1.0/6.0;
    let s = (xin+yin+zin)*F3;
    let i = Math.floor(xin+s), j = Math.floor(yin+s), k = Math.floor(zin+s);
    let t = (i+j+k)*S3;
    let X0 = i-t, Y0 = j-t, Z0 = k-t;
    let x0 = xin-X0, y0 = yin-Y0, z0 = zin-Z0;
    let i1, j1, k1, i2, j2, k2;
    if(x0>=y0 && y0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
    else if(x0>=z0 && z0>=y0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
    else if(y0>=x0 && x0>=z0) { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
    else if(y0>=z0 && z0>=x0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
    else if(z0>=x0 && x0>=y0) { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
    else { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
    let x1 = x0 - i1 + S3, y1 = y0 - j1 + S3, z1 = z0 - k1 + S3;
    let x2 = x0 - i2 + 2.0*S3, y2 = y0 - j2 + 2.0*S3, z2 = z0 - k2 + 2.0*S3;
    let x3 = x0 - 1.0 + 3.0*S3, y3 = y0 - 1.0 + 3.0*S3, z3 = z0 - 1.0 + 3.0*S3;
    let ii = i & 255, jj = j & 255, kk = k & 255;
    let gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12;
    let gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12;
    let gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12;
    let gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12;
    let n0, n1, n2, n3;
    let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
    if(t0<0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0); }
    let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
    if(t1<0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1); }
    let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
    if(t2<0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2); }
    let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
    if(t3<0) n3 = 0.0; else { t3 *= t3; n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3); }
    return 32.0*(n0 + n1 + n2 + n3);
  }
}
const noiseGenerator = new SimpleNoise();

// ─── SCENE ───────────────────────────────────────────────────
const canvasContainer = document.getElementById('canvas-container');
const scene = new THREE.Scene();
const bgColor = 0xa6b0bd; 
scene.fog = new THREE.FogExp2(bgColor, 0.02); 

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 8);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: 'high-performance' });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.9;
renderer.setClearColor(bgColor, 1);
canvasContainer.appendChild(renderer.domElement);

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// ─── SHADERS ─────────────────────────────────────────────────
const MAX_PULSES = 10;
const pulseOrigins = new Float32Array(MAX_PULSES * 3);
const pulseTimers = new Float32Array(MAX_PULSES).fill(100.0);

const uniforms = {
  uTime:         { value: 0.0 },
  uPulseOrigins: { value: pulseOrigins }, 
  uPulseTimers:  { value: pulseTimers },
};

const vertexShader = `
  varying vec3 vNormal;
  varying vec3 vPosition;
  varying vec3 vViewDir;
  varying vec3 vBarycentric; 
  attribute vec3 barycentric; 

  void main() {
    vPosition = position;
    vBarycentric = barycentric; 
    vec4 worldPos = modelMatrix * vec4(position, 1.0);
    vec4 mvPosition = viewMatrix * worldPos;
    vNormal = normalize(normalMatrix * normal);
    vViewDir = normalize(-mvPosition.xyz);
    gl_Position = projectionMatrix * mvPosition;
  }
`;

const fragmentShader = `
  varying vec3 vNormal;
  varying vec3 vPosition;
  varying vec3 vViewDir;
  varying vec3 vBarycentric;
  
  uniform float uTime;
  uniform vec3 uPulseOrigins[10];
  uniform float uPulseTimers[10];

  float getWireframe() {
    float closestEdge = min(vBarycentric.x, min(vBarycentric.y, vBarycentric.z));
    return 1.0 - smoothstep(0.0, 0.012, closestEdge);
  }

  void main() {
    // 1. Ice Material
    vec3 baseColor = vec3(0.58, 0.62, 0.7);
    float NdotV = dot(vNormal, vViewDir);
    float fresnel = pow(1.0 - max(NdotV, 0.0), 3.0);
    vec3 rockColor = baseColor * (0.85 + NdotV * 0.15); 
    rockColor += vec3(0.12) * fresnel;

    // 2. Brightness-Controlled Pulses
    float totalWave = 0.0;
    for(int i = 0; i < 10; i++) {
        float dist = distance(vPosition, uPulseOrigins[i]);
        float timer = uPulseTimers[i];
        float waveRadius = timer * 1.8; 
        
        float pulse = smoothstep(0.4, 0.0, abs(dist - waveRadius));
        float decay = smoothstep(6.0, 0.0, waveRadius);
        
        // Multiplier lowered to 0.7 to prevent brightness explosion
        totalWave += pulse * 0.7 * decay;
    }
    
    // Strict cap on additive light
    float activeGlow = clamp(totalWave, 0.0, 1.1);

    // 3. Triangle Skin
    float wireframe = getWireframe();
    float lineBrightness = (wireframe * 0.04) + (wireframe * activeGlow * 1.4);
    vec3 lineColor = vec3(0.3, 0.85, 1.0);

    vec3 finalColor = rockColor + (lineColor * lineBrightness);
    float alpha = 0.65 + (fresnel * 0.35) + (activeGlow * 0.1);

    gl_FragColor = vec4(finalColor, alpha);
  }
`;

// ─── GEOMETRY (DIRECTIONAL SHARD) ────────────────────────────
function createIceShard() {
  // Tall shard base
  let geometry = new THREE.IcosahedronGeometry(2, 40); 
  
  const posAttribute = geometry.attributes.position;
  const vertex = new THREE.Vector3();

  for (let i = 0; i < posAttribute.count; i++) {
    vertex.fromBufferAttribute(posAttribute, i);
    
    // Shape logic:
    // Sides (mid Y) should be relatively smooth.
    // Ends (top/bottom Y) should be uneven/jagged.
    const yFactor = Math.abs(vertex.y) / 2.0; 
    
    // 1. Jagged Noise (Top/Bottom)
    const nJagged = noiseGenerator.noise(vertex.x * 0.5, vertex.y * 0.5, vertex.z * 0.5);
    
    // 2. Micro Bumps (Faceted ridges)
    const nSharp = Math.abs(noiseGenerator.noise(vertex.x * 3.0, vertex.y * 3.0, vertex.z * 3.0));
    
    // Scale geometry: Tall and Thin
    vertex.x *= 0.7;
    vertex.z *= 0.7;
    vertex.y *= 1.4;

    // Displacement logic
    const displacement = (nJagged * 0.6 * yFactor) + (nSharp * 0.15);
    const dir = vertex.clone().normalize();
    vertex.addScaledVector(dir, displacement);
    
    posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
  }
  
  geometry.computeVertexNormals();
  geometry = geometry.toNonIndexed();
  
  const count = geometry.attributes.position.count;
  const barycentric = new Float32Array(count * 3);
  for (let i = 0; i < count; i+=3) {
    barycentric[i*3+0]=1; barycentric[i*3+1]=0; barycentric[i*3+2]=0;
    barycentric[i*3+3]=0; barycentric[i*3+4]=1; barycentric[i*3+5]=0;
    barycentric[i*3+6]=0; barycentric[i*3+7]=0; barycentric[i*3+8]=1;
  }
  geometry.setAttribute('barycentric', new THREE.BufferAttribute(barycentric, 3));
  return geometry;
}

// ─── MESHES ──────────────────────────────────────────────────
const mainGroup = new THREE.Group();
scene.add(mainGroup);

const shardGeo = createIceShard();
const shardMat = new THREE.ShaderMaterial({
  vertexShader,
  fragmentShader,
  uniforms,
  transparent: true,
  side: THREE.DoubleSide,
});
const iceShard = new THREE.Mesh(shardGeo, shardMat);
mainGroup.add(iceShard);

// Logo Core
const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 });
const logoGeo = new THREE.BoxGeometry(0.7, 0.7, 0.15);
const logoMesh = new THREE.Mesh(logoGeo, coreMat);
mainGroup.add(logoMesh);

mainGroup.rotation.x = 0.3;
mainGroup.rotation.y = 0.5;

// ─── POST-PROCESSING ─────────────────────────────────────────
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.35, 0.3, 0.88);
composer.addPass(bloomPass);

// ─── INTERACTION ─────────────────────────────────────────────
const targetRotation = { x: 0.3, y: 0.5 };
let lastPulsePos = new THREE.Vector3(0,0,0);
let pulseCursor = 0;

window.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  targetRotation.y = 0.5 + mouse.x * 0.1;
  targetRotation.x = 0.3 - mouse.y * 0.1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(iceShard);
  if (intersects.length > 0) {
    const hitPoint = iceShard.worldToLocal(intersects[0].point.clone());
    if (hitPoint.distanceTo(lastPulsePos) > 0.3) { 
      lastPulsePos.copy(hitPoint);
      uniforms.uPulseOrigins.value[pulseCursor * 3]     = hitPoint.x;
      uniforms.uPulseOrigins.value[pulseCursor * 3 + 1] = hitPoint.y;
      uniforms.uPulseOrigins.value[pulseCursor * 3 + 2] = hitPoint.z;
      uniforms.uPulseTimers.value[pulseCursor] = 0.0;
      pulseCursor = (pulseCursor + 1) % MAX_PULSES;
    }
  }
});

// ─── LOOP ────────────────────────────────────────────────────
function animate() {
  requestAnimationFrame(animate);
  uniforms.uTime.value += 0.01;
  for(let i=0; i < MAX_PULSES; i++) uniforms.uPulseTimers.value[i] += 0.008;

  mainGroup.rotation.x += (targetRotation.x - mainGroup.rotation.x) * 0.05;
  mainGroup.rotation.y += (targetRotation.y - mainGroup.rotation.y) * 0.05;
  mainGroup.position.y = Math.sin(uniforms.uTime.value * 0.4) * 0.05;
  logoMesh.rotation.y = uniforms.uTime.value * 0.3;

  composer.render();
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});